package J2021_12_2;

import java.util.Scanner;
/*
序列查询新解

分块思想


公式1: sum += Math.abs((i - 1) - gx) * (A[i] - base);
公式2: sum += Math.abs((i - 1) - gx) * (next_x - base);
1. (i - 1) - gx 表达式的含义
i - 1: 表示当前正在处理的商品的索引。假设你现在正在处理第 i 个商品（即 A[i]），那么 i - 1 就表示这个商品在数组中的位置（即前一个位置）。

gx: 表示“实际的分块下标”。这意味着当前商品的价格应该落在某个分块内，而 gx 是用来追踪你正在处理的哪个分块。

(i - 1) - gx：这个表达式表示当前商品的索引与它所属的分块的差值，这个差值的绝对值用来衡量当前商品离它应该在的分块有多远。这种距离表示了“错位”的程度：如果商品价格正好落在它应该所在的分块内，那么 i - 1 和 gx 是相等的，所以差值为 0。如果商品价格越偏离它应该在的分块，则差值越大。

2. 公式1: sum += Math.abs((i - 1) - gx) * (A[i] - base);
Math.abs((i - 1) - gx): 表示当前商品的“错位”程度。

(A[i] - base): 表示当前商品价格与前一个分块边界之间的差值。base 是前一个分块的右边界，所以 (A[i] - base) 是当前商品价格与前一个分块右边界的差值。

整个公式: sum += Math.abs((i - 1) - gx) * (A[i] - base);

这个公式的作用是：将当前商品价格与它应该所属的分块之间的差值（也就是“错位程度”）乘以价格与上一个分块右边界的差值，累加到 sum 中。这个乘积代表了价格在区间中的不均匀程度的影响——错位越大，贡献的影响也越大。

3. 公式2: sum += Math.abs((i - 1) - gx) * (next_x - base);
Math.abs((i - 1) - gx): 和上面的公式相同，表示当前商品的“错位”程度。

(next_x - base): 表示当前分块的右边界与前一个分块的右边界之间的距离。next_x 是当前分块的右边界，而 base 是前一个分块的右边界，所以 (next_x - base) 是两个分块之间的“跨度”。

整个公式: sum += Math.abs((i - 1) - gx) * (next_x - base);

这个公式的作用是：当商品价格跨越了当前分块时，计算分块右边界之间的距离，并将错位程度与这个距离的乘积累加到 sum 中。这表示商品价格在当前分块和前一个分块之间的偏差影响。

为什么要用这两个公式？
这两个公式的目的都是为了计算每个商品价格与其所属分块之间的距离偏差对总差值的影响。因为商品价格不总是恰好落在某个分块的边界上，所以必须计算它与分块边界之间的距离以及它在分块中的错位程度。通过将这些错位程度和距离相乘，代码可以衡量出商品价格的分布不均匀性，并将其累加到 sum 中，从而反映出整个价格分布与理想分块之间的偏差。

总结
Math.abs((i - 1) - gx)：用来衡量当前商品价格与它所属分块之间的错位程度。
(A[i] - base) 和 (next_x - base)：分别表示当前商品价格与前一个分块边界、当前分块边界之间的差值。
公式1 和 公式2：都通过将错位程度和差值相乘，来衡量商品价格分布的不均匀性，并将其累加到总差值 sum 中。

 */
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // 读取商品数目 n 和总数 N
        int n = sc.nextInt(); // 商品数目
        int N = sc.nextInt(); // 总数

        // 初始化存储商品价格的数组，长度为 n + 2
        // 其中 A[0] = 0 表示区间的起始点
        // A[n + 1] = N 表示区间的结束点
        int[] A = new int[n + 2]; // 存储商品价格的数组
        A[0] = 0;  // 区间的起始点
        A[n + 1] = N; // 区间的结束点

        // 输入每个商品的价格
        for (int i = 1; i <= n; i++) {
            A[i] = sc.nextInt(); // 输入每个商品的价格
        }

        // 计算每个分块的大小 r，即总区间 N 被 n+1 等分
        int r = N / (n + 1); // 分块大小

        // gx 代表实际的分块下标, 初始化为 0
        int gx = 0; // 实际下标

        // next_x 代表下一个分块的起始值
        // 之后base永远小于next_x一个身位，少一个r的大小
        int next_x = r; // 下一个分块的起始值，之后循环不断加上+r

        // sum 用于累加所有区间的差值
        long sum = 0; // 差值之和

        // 遍历商品价格数组，从第一个商品到最后一个
        for (int i = 1; i <= n + 1; i++) {
            // 当前区间的左端点值
            int base = A[i - 1]; // 当前区间左端点值

            // 进入循环以处理当前商品价格与分块的关系
            while (true) {
                // 如果当前商品的价格小于下一个分块的起始值
                if (A[i] < next_x) {
                    // 计算当前分块与实际分块之间的差值并累加
                    sum += Math.abs((i - 1) - gx)    *     (A[i] - base); // 计算差值并累加
                    break; // 跳出循环处理下一个商品价格
                } else {
                    // 如果当前商品价格大于等于下一个分块的起始值
                    // 计算到下一个分块的差值并累加
                    sum += Math.abs((i - 1) - gx)    *      (next_x - base); // 计算差值并累加

                    // 如果商品价格正好等于下一个分块的起始值，跳出循环
                    if (A[i] == next_x) break;

                    // 否则，更新 base 为下一个分块的起始值
                    base = next_x; // 更新当前区间左端点值

                    // 更新下一个分块的起始值
                    next_x += r; // 下一个分块的起始值

                    // 更新实际分块下标
                    gx++; // 更新实际下标
                }
            }
        }
        // 输出累加的差值之和
        System.out.println(sum);
    }
}
